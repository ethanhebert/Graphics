'''
Ethan Hebert
10381833
2-28-23
Assignment 4
This program generates a still image of 4 spheres on a checkerboard plane using
a recursive ray tracing method which displays reflections, refractions, and objects' local
colors generated by Phong shading along with shadows.
'''

# Import libraries
import math
from tkinter import *

# Constants
CANVASWIDTH = 800
CANVASHEIGHT = 500
D = 500
HORIZON = 3000
SKYCOLOR = [0.7,0.8,1]
DEPTH = 4
REFRACTDENSITY = 1.6 # density of glass compared to air

# Lighting constants
IA = 0.25 # intensity of the ambient light in the scene
IP = 1 - IA # intensity of the point light source in the scene
LIGHTSOURCE = [500,500,-500] # light source, 45 degree angle, light behind viewer's right shoulder (more accurate than lighting vector - allows shadows)
COP = [0,0,-D] # center of projection (the viewer's eyeball)

# Classes to define a sphere and a checkerboard with its instance vars and intersect functions (and getColor for checkerboard)
class Sphere:
    # constructor to store all instance vars
    def __init__(self,centerPoint,radius,localColor,Kd,Ks,specIndex,localWeight,reflectWeight,refractWeight):
        self.centerPoint = centerPoint
        self.l = centerPoint[0]
        self.m = centerPoint[1]
        self.n = centerPoint[2]
        self.r = radius
        self.localColor = localColor
        self.Kd = Kd
        self.Ks = Ks
        self.specIndex = specIndex
        self.localWeight = localWeight
        self.reflectWeight = reflectWeight
        self.refractWeight = refractWeight
        self.t = 0
        self.phongIntensity = 0
        self.intersectionPoint = [0,0,0]
        self.surfaceNormal = [0,0,0]
        self.reflect = [0,0,0]
        self.refract = [0,0,0]

    # calculate all intersection points of a ray with this object (if any)
    # store the new t value and new intersectionPoint
    # return a bool if there was an intersection or not
    def intersect(self,startPoint,ray):
        # calculate equation values
        i = ray[0]
        j = ray[1]
        k = ray[2]
        x1 = startPoint[0]
        y1 = startPoint[1]
        z1 = startPoint[2]
        a = i**2 + j**2 + k**2
        b = 2*i*(x1-self.l) + 2*j*(y1-self.m) + 2*k*(z1-self.n)
        c = self.l**2 + self.m**2 + self.n**2 + x1**2 + y1**2 + z1**2 + 2*(-self.l*x1 - self.m*y1 - self.n*z1) - self.r**2
        discriminant = b**2 - 4*a*c
        # no real roots (no intersection)
        if (discriminant < 0):
            return False
        # one or two real roots (one or two intersections - select nearest)
        else:
            t1 = (-b + math.sqrt(discriminant))/(2*a)
            t2 = (-b - math.sqrt(discriminant))/(2*a)
            t = min(t1,t2)
        # no visible intersection
        if (t < 0.001):
            return False
        # ray strikes the sphere, count as visible
        # update t value and intersectionPoint in self
        # update the surface normal values at this intersection point
        for i in range(3):
            self.intersectionPoint[i] = startPoint[i] + ray[i]*t
            self.surfaceNormal[i] = self.intersectionPoint[i] - self.centerPoint[i]
        self.t = t
        # update the Phong intensity value for this intersection point
        self.phongIntensity = phong(self.intersectionPoint,self.surfaceNormal,self.Kd,self.Ks,self.specIndex)
        # update the reflect value for this intersection point
        negRay = []
        for i in range(3):
            negRay.append(-ray[i])
        self.reflect = reflect(self.surfaceNormal,negRay)
        # update the refract value at this point (if this sphere has refraction)
        if (self.refractWeight > 0):
            d = REFRACTDENSITY
            for i in range(3):
                self.refract[i] = (1/d)*ray[i] - (math.sqrt(1 - (1/(d**2))*(1 - (-ray[0]*self.surfaceNormal[0] - \
                     ray[1]*self.surfaceNormal[1] - ray[2]*self.surfaceNormal[2])**2)) - (1/d)*(-ray[0]*self.surfaceNormal[0] \
                     - ray[1]*self.surfaceNormal[1] - ray[2]*self.surfaceNormal[2]))*self.surfaceNormal[i]
        return True

class Checkerboard:
    # constructor to store all instance vars
    def __init__(self,surfaceNormal,anchorPoint,Kd,Ks,specIndex,localWeight,reflectWeight,refractWeight):
        self.surfaceNormal = surfaceNormal
        self.a = surfaceNormal[0]
        self.b = surfaceNormal[1]
        self.c = surfaceNormal[2]
        self.d = self.a*anchorPoint[0] + self.b*anchorPoint[1] + self.c*anchorPoint[2]
        self.Kd = Kd
        self.Ks = Ks
        self.specIndex = specIndex
        self.localWeight = localWeight
        self.reflectWeight = reflectWeight
        self.refractWeight = refractWeight
        self.t = 0
        self.localColor = [1,0,0]
        self.phongIntensity = 0
        self.intersectionPoint = [0,0,0]
        self.reflect = [0,0,0]
        self.refract = [0,0,0]

    # calculate the intersection point of a ray with this object (if there is one)
    # store the new t value and new intersectionPoint
    # find this point's localColor (red or white)
    # return a bool if there was an intersection or not
    def intersect(self,startPoint,ray):
        denom = self.a*ray[0] + self.b*ray[1] + self.c*ray[2]
        # traced ray is parallel to plane (no intersection)
        if (abs(denom) <= 0.001):
            return False
        # calculate the t value
        t = -(self.a*startPoint[0] + self.b*startPoint[1] + self.c*startPoint[2] - self.d)/denom
        # ray strikes the plane behind the center of projection (treat as no intersection)
        if (t < 0.001):
            return False
        # ray intersects at a negative z value or at a z value past the visual horizon (treat as no intersection)
        intersection = []
        for i in range(3):
            intersection.append(startPoint[i] + ray[i]*t)
        if (intersection[2] < 0 or intersection[2] > HORIZON):
            return False
        # ray strikes the plane in front of the center of projection, z >=0 and z < HORIZON, count as visible
        # update t value and intersectionPoint in self
        self.t = t
        self.intersectionPoint = intersection
        # update the localColor for this intersection point
        self.getColor()
        # update the Phong intensity value for this intersection point
        self.phongIntensity = phong(self.intersectionPoint,self.surfaceNormal,self.Kd,self.Ks,self.specIndex)
        # update the reflect value for this intersection point
        negRay = []
        for i in range(3):
            negRay.append(-ray[i])
        self.reflect = reflect(self.surfaceNormal,negRay)
        return True
    
    # This function changes self.localColor to be red or white based on where
    # the current intersectionPoint is to make the checkerboard pattern
    def getColor(self):
        # get this point's localColor (red or white)
        if (self.intersectionPoint[0] >= 0):
            colorFlag = True
        else:
            colorFlag = False
        if (abs(self.intersectionPoint[0])%400 > 200):
            colorFlag = not(colorFlag)
        if (abs(self.intersectionPoint[2])%400 > 200):
            colorFlag = not(colorFlag)
        if (colorFlag):
            self.localColor = [1,0,0]
        else:
            self.localColor = [1,1,1]

# Define the spheres in the scene given: centerPoint, radius, local RGB color,
# Kd, Ks, specIndex, weights for local, reflect, refract
redSphere = Sphere([375,-125,300], 175, [1,0.2,0.8], 0.4, 0.6, 4, 0.6, 0.4, 0.0)
greenSphere = Sphere([-400,-175,300], 100, [0.9,1,0.3], 0.4, 0.6, 4, 0.6, 0.4, 0.0)
blueSphere = Sphere([100,0,800], 300, [0.2,0.7,1], 0.4, 0.6, 4, 0.6, 0.4, 0.0)
clearSphere = Sphere([-150,-200,200], 75, [1,1,1], 0.1, 0.9, 8, 0.1, 0.1, 0.8)

# Define the checkerboard plane given: surface normal, an anchor point, Kd, Ks,
# specIndex, weights for local, reflect, refract
board = Checkerboard([0,1,0], [0,-300,0], 0.6, 0.4, 8, 0.6, 0.4, 0.0)

# The scene consists of all objects
SCENE = [redSphere, greenSphere, blueSphere, clearSphere, board]

# FUNCTIONS
# Traces a single ray, returning the color of the pixel as an [R,G,B] list,
# using a 0-1 scale
def traceRay(startPoint, ray, depth):
    # return "black" when you reach the bottom of the recursive calls
    if (depth == 0):
        return [0,0,0]
    # intersect the ray with all objects to determine nearest object (if any)
    tMin = 999999 # initialize t to a very large number
    for object in SCENE:
        if (object.intersect(startPoint,ray)):
            if (object.t < tMin):
                tMin = object.t
                nearestObject = object
    # return SKYCOLOR if no intersection
    if (tMin == 999999):
        return SKYCOLOR
    # determine localColor and the weight for that color at the intersection point
    color = nearestObject.localColor
    intensity = nearestObject.phongIntensity
    if (inShadow(nearestObject, nearestObject.intersectionPoint)):
        intensity *= 0.25
    localColor = [color[0]*intensity*2, color[1]*intensity*2, color[2]*intensity*2] # *2 to increase local color intensity
    localWeight = nearestObject.localWeight
    # compute the color returned from the reflected ray
    reflectWeight = nearestObject.reflectWeight
    reflectColor = traceRay(nearestObject.intersectionPoint, nearestObject.reflect, depth-1)
    # compute the color and weight of the refracted ray
    refractWeight = nearestObject.refractWeight
    if (refractWeight > 0): # only compute if the object has refraction
        refractColor = traceRay(nearestObject.intersectionPoint, nearestObject.refract, depth-1)
    else:
        refractColor = [0,0,0]
    # combine the local, reflected, and refracted colors together using their respective weights
    returnColor = [0,0,0]
    for i in range(3):
        returnColor[i] = localColor[i]*localWeight + reflectColor[i]*reflectWeight + refractColor[i]*refractWeight
    return returnColor

# Determines if a point is in shadow by tracing a ray back to the light source
def inShadow(startObject,startPoint):
    ray = computeUnitVector(startPoint,LIGHTSOURCE)
    for object in SCENE:
        if (startObject != object and object.intersect(startPoint,ray)):
            return True
    return False

# Calculate the Phong intensity at the current intersection point of an object
def phong(intersectionPoint,surfaceNormal,Kd,Ks,specIndex):
    # normalize all vectors
    l = normalize(computeUnitVector(intersectionPoint,LIGHTSOURCE))
    v = normalize(COP)
    n = normalize(surfaceNormal)
    # calculate ambient
    ambient = IA*Kd
    # calculate diffuse
    ndotl = n[0]*l[0] + n[1]*l[1] + n[2]*l[2]
    if ndotl < 0: ndotl = 0
    diffuse = IP*Kd*ndotl
    # calculate specular
    r = reflect(n,l) # return vector is normalized in "reflect"
    rdotv = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]
    if rdotv < 0: rdotv = 0
    specular = IP*Ks*rdotv**specIndex
    # return phongIntensity
    phongIntensity = ambient + diffuse + specular
    return phongIntensity

# Takes in a color as a [R,G,B] list with a 0-1 scale, converts this to
# a color string, and returns the color string 
def RGBColorHexCode(color):
    colorCode = "#"
    for i in range(3):
        rgbVal = round(255*color[i])
        # make sure rgb val is from 0-255
        if (rgbVal < 0):
            rgbVal = 0
        elif (rgbVal > 255):
            rgbVal = 255
        hexString = str(hex(rgbVal))[2:]
        # make single digit hex values 2 digit
        if (len(hexString) == 1):
            hexString = "0" + hexString
        colorCode += hexString
    return colorCode
    
# Computes the unit vector between a source and destination point
def computeUnitVector(source,destination):
    vector = []
    for i in range(len(source)):
        vector.append(destination[i]-source[i])
    return normalize(vector)

# Convert an N dimensional vector into a unit vector (normalize the vector)
def normalize(vector):
    sumOfSquares = 0
    for i in range(len(vector)):
        sumOfSquares += vector[i]**2
    magnitude = math.sqrt(sumOfSquares)
    vect = []
    for i in range(len(vector)):
        vect.append(vector[i]/magnitude)
    return vect

# Calculate a 3-D reflection vector, r, given surface normal, n, and lighting vetor, l
def reflect(n,l):
    r = []
    n = normalize(n)
    l = normalize(l)
    twoCosPhi = 2*(n[0]*l[0] + n[1]*l[1] + n[2]*l[2])
    if twoCosPhi > 0:
        for i in range(3):
            r.append(n[i] - (l[i]/twoCosPhi))
    elif twoCosPhi == 0:
        for i in range(3):
            r.append(-l[i])
    else: # twoCosPhi < 0
        for i in range(3):
            r.append(-n[i] + (l[i]/twoCosPhi))
    return normalize(r)

# Renders the entire image by tracing and filling a single pixel at a time
def renderImage():
    top = round(CANVASHEIGHT/2)
    bottom = round(-CANVASHEIGHT/2)
    left = round(-CANVASWIDTH/2)
    right = round(CANVASWIDTH/2)
    for y in range(top,bottom,-1):
        for x in range(left,right):
            ray = computeUnitVector(COP,[x,y,0])
            color = traceRay(COP, ray, DEPTH)
            w.create_line(right+x, top-y, right+x+1, top-y, fill=RGBColorHexCode(color))

# MAIN LOOP
# Define a drawing canvas and render the image on it
root = Tk()
outerframe = Frame(root)
outerframe.pack()
w = Canvas(outerframe,width=CANVASWIDTH,height=CANVASHEIGHT)
renderImage()
w.pack()
root.mainloop()